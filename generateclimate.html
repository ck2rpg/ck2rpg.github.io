<!doctype html>
<html lang="en">
<head>
 <meta charset="utf-8">
 <title>Köppen Generator — Latitude + Elevation (Heightmap Upload)</title>
 <meta name="viewport" content="width=device-width,initial-scale=1">
 <style>
:root{
  /* Continent-maker parchment + ink */
  --parchment-bg:#f4e9d5;
  --parchment-dark:#e8dbc3;
  --ink:#3c2f21;
  --ink-muted:#6b5a46;
  --accent:#a65d37;
  --border:#c4b496;
  --shadow:0 4px 20px rgba(0,0,0,.15);
  --font-serif:"Georgia","Times New Roman",serif;
  --font-mono:"Courier New",Courier,monospace;

  /* semantic */
  --danger:#b54b3c;
}

*{box-sizing:border-box}
html,body{height:100%}

body{
  margin:0;
  background:#2a241e; /* dark wood surround */
  color:var(--ink);
  font-family:var(--font-serif);
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

/* Parchment header strip */
header{
  padding:18px 20px;
  border-bottom:1px double var(--ink);
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:12px;
  background:var(--parchment-bg);
  box-shadow:0 4px 18px rgba(0,0,0,.25);
  backdrop-filter:none;
  background-image:radial-gradient(circle at 50% 50%, rgba(255,255,255,.20) 0%, transparent 100%);
}

header h1{
  margin:0;
  font-size:1.05rem;
  letter-spacing:1px;
  text-transform:uppercase;
  color:var(--ink);
  border-bottom:1px solid var(--ink);
  display:inline-block;
  padding-bottom:4px;
}

header .sub{
  font-size:.75rem;
  color:var(--ink-muted);
  font-style:italic;
}

/* Layout */
main{
  flex:1;
  display:flex;
  min-height:0;
}

/* Sidebar -> parchment panel */
#sidebar{
  width:340px;
  max-width:100%;
  border-right:2px solid var(--ink);
  padding:16px;
  display:flex;
  flex-direction:column;
  gap:12px;
  background:var(--parchment-bg);
  box-shadow:5px 0 15px rgba(0,0,0,.30);
  background-image:radial-gradient(circle at 50% 50%, rgba(255,255,255,.20) 0%, transparent 100%);
  overflow:auto;
}

/* Right side -> dark stage */
#canvas-wrap{
  flex:1;
  display:flex;
  flex-direction:column;
  min-width:0;
  background:#1a1612;
}

/* Canvas bar -> subtle parchment-ish strip */
#canvas-bar{
  padding:10px 12px;
  font-size:.75rem;
  color:var(--ink-muted);
  border-bottom:1px solid rgba(0,0,0,.25);
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
  background:rgba(244,233,213,.55);
  backdrop-filter:none;
}

/* Canvas itself -> continent-maker full-height behavior */
#canvas{
  flex:1;
  max-width:100%;
  display:block;
  background:#fff;
  image-rendering:pixelated;
}

/* Section labels */
.section-label{
  font-size:.75rem;
  text-transform:uppercase;
  letter-spacing:1px;
  color:var(--ink-muted);
  font-weight:700;
  border-bottom:1px solid var(--border);
  padding-bottom:6px;
}

/* Cards -> plugin-card parchment blocks */
.card{
  border-radius:2px;
  border:1px solid var(--ink-muted);
  background:var(--parchment-dark);
  padding:12px 12px 12px;
  box-shadow:2px 2px 5px rgba(0,0,0,.06);
}

.card h2{
  margin:0 0 6px;
  font-size:.9rem;
  font-weight:700;
  color:var(--ink);
}

.card p{
  margin:2px 0;
  font-size:.78rem;
  color:var(--ink-muted);
  font-style:italic;
}

/* Fields */
.field{
  margin-top:10px;
  display:flex;
  flex-direction:column;
  gap:4px;
}

.field label{
  font-size:.78rem;
  color:var(--ink);
}

.field-row{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
}

input[type="file"]{
  font-size:.78rem;
  color:var(--ink-muted);
}

/* Inputs -> continent maker style */
input[type="number"]{
  width:88px;
  padding:8px;
  font-size:13px;
  border-radius:2px;
  border:1px solid var(--ink-muted);
  background:rgba(255,255,255,.40);
  color:var(--ink);
  font-family:var(--font-mono);
}
input[type="number"]:focus{
  outline:2px solid var(--accent);
  background:#fff;
}

input[type="checkbox"]{
  accent-color:var(--accent);
}

/* Buttons -> continent-maker buttons */
button{
  border-radius:2px;
  border:1px solid var(--ink);
  background:var(--parchment-dark);
  color:var(--ink);
  font-size:12px;
  padding:10px 12px;
  display:inline-flex;
  align-items:center;
  gap:6px;
  cursor:pointer;
  white-space:nowrap;
  font-family:var(--font-serif);
  font-weight:700;
  letter-spacing:.6px;
  text-transform:uppercase;
  box-shadow:2px 2px 0 var(--ink);
  transition:background .1s, transform .1s, box-shadow .1s;
}

button:hover{ background:#dfcfaf; }
button:active{
  transform:translate(1px,1px);
  box-shadow:1px 1px 0 var(--ink);
}

button.primary{
  background:var(--accent);
  color:#fff;
  border-color:var(--ink);
}

button:disabled{
  opacity:.45;
  cursor:default;
  box-shadow:none;
  transform:none;
}

/* Pills -> small parchment tags */
.pill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  border-radius:999px;
  border:1px solid var(--border);
  padding:2px 8px;
  font-size:11px;
  color:var(--ink-muted);
  background:rgba(255,255,255,.35);
}

.pill-dot{
  width:6px;
  height:6px;
  border-radius:999px;
  background:var(--accent);
}

#status{
  font-size:11px;
  color:var(--ink-muted);
  font-style:italic;
}

/* Legend -> parchment tiles */
#legend{
  margin-top:8px;
  display:grid;
  grid-template-columns:repeat(3, minmax(0, 1fr));
  gap:6px;
  max-height:200px;
  overflow:auto;
  padding-right:2px;
}

.legend-item{
  display:flex;
  align-items:center;
  gap:6px;
  padding:6px 8px;
  border-radius:2px;
  background:rgba(255,255,255,.35);
  border:1px solid var(--border);
}

.swatch{
  width:16px;
  height:12px;
  border-radius:2px;
  border:1px solid rgba(0,0,0,.25);
}

.legend-code{
  font-size:12px;
  font-family:var(--font-mono);
  color:var(--ink);
}

.legend-name{
  font-size:11px;
  color:var(--ink-muted);
  font-style:italic;
}

/* Metrics text */
#metrics{
  font-size:12px;
  color:var(--ink-muted);
  margin-top:6px;
  line-height:1.4;
  white-space:pre-line;
  font-style:italic;
}

 </style>
</head>

<body>
 <header>
  <div>
   <h1>KÖPPEN CLIMATE GENERATOR</h1>
   <div class="sub">Latitude base → distance/currents → elevation lapse → render</div>
  </div>
  <div class="pill">
   <span class="pill-dot"></span>
   <span id="status">Awaiting heightmap…</span>
  </div>
 </header>
 <main>
  <aside id="sidebar">
   <div class="section-label">Input</div>
   <div class="card">
    <h2>Heightmap Upload</h2>
    <p>Use a greyscale PNG. Land should be higher values, oceans lower. By default, greyscale &lt; 19 = ocean.</p>

    <div class="field">
     <label for="file">Heightmap (PNG, JPG):</label>
     <input id="file" type="file" accept="image/png,image/jpeg,image/webp">
    </div>

    <div class="field">
     <label for="sea">Sea level threshold (0–255):</label>
     <div class="field-row">
      <input id="sea" type="number" min="0" max="255" value="19">
      <span style="font-size:10px;color:var(--muted)">Below this is ocean (ignored for land climate).</span>
     </div>
    </div>

    <!-- ADDED: Latitude band controls -->
    <div class="field">
      <label>Latitude band (degrees):</label>
      <div class="field-row">
        <div>
          <div style="font-size:10px;color:var(--muted)">Top</div>
          <input id="latTop" type="number" min="-90" max="90" value="90" step="0.1">
        </div>
        <div>
          <div style="font-size:10px;color:var(--muted)">Bottom</div>
          <input id="latBottom" type="number" min="-90" max="90" value="-90" step="0.1">
        </div>
      </div>
      <div style="font-size:10px;color:var(--muted)">
        Example: Top=45, Bottom=23 generates a mid-latitude Northern Hemisphere slice. Top=90, Bottom=-90 reproduces full globe.
      </div>
    </div>
   </div>

   <div class="section-label">Plugins</div>
   <div class="card">
    <h2>Pipeline Order</h2>
    <p>Plugins are run top-to-bottom; checkboxes are generated automatically from the registry.</p>
    <div id="plugin-list"></div>
    <div class="field" style="margin-top:10px;">
     <label>Temperature model (°C):</label>
     <div style="font-size:10px;color:var(--muted);">
      <strong>Equator:</strong> 27°C &nbsp;&nbsp; <strong>Poles:</strong> −15°C &nbsp;&nbsp;
      <strong>Lapse:</strong> −6.5°C/km
     </div>
    </div>
    <div class="field" style="margin-top:10px;">
     <button id="run" class="primary" disabled>Generate Köppen Map</button>
    </div>
   </div>

   <div class="section-label">Legend</div>
   <div class="card">
    <h2>Köppen Classes</h2>
    <div id="legend"></div>
    <div id="metrics"></div>
   </div>
  </aside>

  <section id="canvas-wrap">
   <div id="canvas-bar">
    <span>Output — Köppen climate colors (ocean in deep blue)</span>
    <span id="dim-label"></span>
   </div>
   <canvas id="canvas"></canvas>
  </section>
 </main>

 <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  const fileInput = document.getElementById('file');
  const seaInput = document.getElementById('sea');
  const latTopInput = document.getElementById('latTop');       // ADDED
  const latBottomInput = document.getElementById('latBottom'); // ADDED
  const runBtn = document.getElementById('run');
  const statusEl = document.getElementById('status');
  const dimLabel = document.getElementById('dim-label');
  const legendEl = document.getElementById('legend');
  const metricsEl = document.getElementById('metrics');
  const pluginListEl = document.getElementById('plugin-list');

  // -------------------------
  // ADDED: latitude helpers
  // -------------------------
  function lerp(a,b,t){ return a + (b-a)*t; }
  // y=0 => topLat, y=H-1 => botLat
  function latAtRow(y, H, topLat, botLat){
    const t = (H <= 1) ? 0 : (y / (H - 1)); // 0..1
    return lerp(topLat, botLat, t);         // can be + to -, any band
  }

  // Simple "Program" with plugin registry
  const Program = {
   state: {
    W: 0, H: 0,
    sea: 19,
    latTop: 90,        // ADDED (default full globe)
    latBottom: -90,    // ADDED (default full globe)
    elev: null,        // Float32Array (0–255 greyscale)
    distToCoast: null, // Int32Array (pixel distance to ocean)
    src: null,         // ImageData of original heightmap
    work: null,        // ImageData for drawing
    rowClimate: null,  // per-row climate baselines
    koppenCodes: null, // Uint8Array of class indices (255 = ocean)
    perCellClimate: null,
    distWest: null,
    distEast: null,
   },
   plugins: [],
   register(p) {
    if (typeof p.enabled === 'undefined') p.enabled = true;
    if (!p.id) p.id = 'plugin-' + (this.plugins.length + 1);
    this.plugins.push(p);
   },
   async run() {
    const st = this.state;
    const enabled = this.plugins.filter(p => p.enabled !== false);
    const total = enabled.length;
    let step = 0;
    for (const p of enabled) {
     step++;
     if (p.id !== 'koppen-dist-to-coast') {
      setStatus(`Running plugin ${step}/${total}: ${p.name}…`);
     }
     await p.run(st);
    }
    setStatus('Done. Köppen map generated.');
   },
   renderPluginUI() {
    if (!pluginListEl) return;
    pluginListEl.innerHTML = '';
    this.plugins.forEach((p, idx) => {
     const row = document.createElement('div');
     row.className = 'field-row';
     row.style.marginTop = '6px';

     const cb = document.createElement('input');
     cb.type = 'checkbox';
     cb.checked = p.enabled !== false;
     cb.addEventListener('change', () => {
      p.enabled = cb.checked;
     });

     const wrap = document.createElement('div');
     const title = document.createElement('div');
     title.style.fontSize = '11px';
     title.textContent = `${idx + 1}. ${p.name}`;
     const desc = document.createElement('div');
     desc.style.fontSize = '10px';
     desc.style.color = 'var(--muted)';
     desc.textContent = p.uiDesc || '';
     wrap.appendChild(title);
     if (p.uiDesc) wrap.appendChild(desc);

     row.appendChild(cb);
     row.appendChild(wrap);
     pluginListEl.appendChild(row);
    });
   }
  };

  // ---- Koppen definitions & colors (Unchanged) ----
  const KOPPEN_CLASSES = [
   { code: 'Af', name: 'Equatorial rainforest', group: 'A', color: '#3c00fb' },
   { code: 'Am', name: 'Equatorial monsoon', group: 'A', color: '#2f66fb' },
   { code: 'Aw', name: 'Equatorial savanna (winter dry)', group: 'A', color: '#4597fb' },
   { code: 'As', name: 'Equatorial savanna (summer dry)', group: 'A', color: '#46be28' },

   { code: 'BWh', name: 'Subtropical desert (hot)', group: 'B', color: '#fd0f00' },
   { code: 'BWk', name: 'Mid-latitude desert (cold)', group: 'B', color: '#fe928f' },
   { code: 'BSh', name: 'Subtropical steppe (hot)', group: 'B', color: '#f3a000' },
   { code: 'BSk', name: 'Mid-latitude steppe (cold)', group: 'B', color: '#fad95d' },

   { code: 'Csa', name: 'Mediterranean hot summer', group: 'C', color: '#f6ff09' },
   { code: 'Csb', name: 'Mediterranean warm summer', group: 'C', color: '#c8cb07' },
   { code: 'Csc', name: 'Mediterranean cool summer', group: 'C', color: '#ffcda0' },

   { code: 'Cfa', name: 'Humid subtropical (no dry season, hot)', group: 'C', color: '#bdff4b' },
   { code: 'Cfb', name: 'Marine west coast (warm summer)', group: 'C', color: '#4dff35' },
   { code: 'Cfc', name: 'Marine west coast (cool summer)', group: 'C', color: '#0ec506' },

   { code: 'Cwa', name: 'Humid subtropical (dry winter, hot summer)', group: 'C', color: '#89ff93' },
   { code: 'Cwb', name: 'Humid subtropical highland (warm summer)', group: 'C', color: '#51c660' },
   { code: 'Cwc', name: 'Humid subtropical highland (cool summer)', group: 'C', color: '#219230' },

   { code: 'Dfa', name: 'Humid continental hot summer', group: 'D', color: '#00fafd' },
   { code: 'Dfb', name: 'Humid continental warm summer', group: 'D', color: '#44c2f9' },
   { code: 'Dfc', name: 'Subarctic cool summer', group: 'D', color: '#007b7c' },
   { code: 'Dfd', name: 'Subarctic very cold winter', group: 'D', color: '#02445a' },

   { code: 'Dsa', name: 'Continental hot summer, dry summer', group: 'D', color: '#ff00f9' },
   { code: 'Dsb', name: 'Continental warm summer, dry summer', group: 'D', color: '#ca00c1' },
   { code: 'Dsc', name: 'Continental cool summer, dry summer', group: 'D', color: '#962791' },
   { code: 'Dsd', name: 'Continental very cold winter, dry summer', group: 'D', color: '#8c568d' },

   { code: 'Dwa', name: 'Humid continental dry winter, hot summer', group: 'D', color: '#a4a7ff' },
   { code: 'Dwb', name: 'Humid continental dry winter, warm summer', group: 'D', color: '#506edf' },
   { code: 'Dwc', name: 'Subarctic dry winter, cool summer', group: 'D', color: '#4c47b0' },
   { code: 'Dwd', name: 'Subarctic dry winter, very cold winter', group: 'D', color: '#350087' },

   { code: 'ET', name: 'Tundra', group: 'E', color: '#a9aca8' },
   { code: 'EF', name: 'Ice cap', group: 'E', color: '#626361' },

   { code: 'H', name: 'Complex highland', group: 'H', color: '#808080' }
  ];

  const CODE_TO_INDEX = (() => {
   const m = {};
   KOPPEN_CLASSES.forEach((c, i) => { m[c.code] = i; });
   return m;
  })();

  function hexToRgb(hex) {
   const s = hex.replace('#', '');
   const v = parseInt(s, 16);
   return [(v >> 16) & 255, (v >> 8) & 255, v & 255];
  }

  // ---- Status helpers (Unchanged) ----
  function setStatus(msg) { statusEl.textContent = msg; }

  function setDimensionsLabel() {
   const st = Program.state;
   if (st.W && st.H) {
    dimLabel.textContent = `${st.W} × ${st.H} px · Sea level = ${st.sea} · Lat ${st.latTop.toFixed(1)} → ${st.latBottom.toFixed(1)}`;
   } else {
    dimLabel.textContent = '';
   }
  }

  // ---- UI: Legend (Unchanged) ----
  function buildLegend() {
   legendEl.innerHTML = '';
   KOPPEN_CLASSES.forEach(c => {
    const div = document.createElement('div');
    div.className = 'legend-item';
    const sw = document.createElement('div');
    sw.className = 'swatch';
    sw.style.background = c.color;
    const textWrap = document.createElement('div');
    const codeEl = document.createElement('div');
    codeEl.className = 'legend-code';
    codeEl.textContent = c.code;
    const nameEl = document.createElement('div');
    nameEl.className = 'legend-name';
    nameEl.textContent = c.name;
    textWrap.appendChild(codeEl);
    textWrap.appendChild(nameEl);
    div.appendChild(sw);
    div.appendChild(textWrap);
    legendEl.appendChild(div);
   });
  }
  buildLegend();

  // -------------------------
  // ADDED: latitude band sync
  // -------------------------
  function syncLatBand(){
    const st = Program.state;
    const a = parseFloat(latTopInput.value);
    const b = parseFloat(latBottomInput.value);
    if (Number.isFinite(a)) st.latTop = Math.max(-90, Math.min(90, a));
    if (Number.isFinite(b)) st.latBottom = Math.max(-90, Math.min(90, b));
    setDimensionsLabel();
  }
  latTopInput.addEventListener('change', syncLatBand);
  latBottomInput.addEventListener('change', syncLatBand);
  syncLatBand();

  // ---- File loading (Unchanged except label refresh) ----
  fileInput.addEventListener('change', e => {
   const file = e.target.files[0];
   if (!file) return;
   const url = URL.createObjectURL(file);
   const img = new Image();
   img.onload = () => {
    const W = img.width;
    const H = img.height;
    canvas.width = W;
    canvas.height = H;
    ctx.drawImage(img, 0, 0);
    const src = ctx.getImageData(0, 0, W, H);
    const N = W * H;
    const elev = new Float32Array(N);
    const st = Program.state;

    st.W = W;
    st.H = H;
    st.sea = parseInt(seaInput.value) || 19;
    syncLatBand(); // ADDED: keep state in sync

    st.src = src;
    st.work = ctx.createImageData(W, H);
    st.elev = elev;
    st.rowClimate = null;
    st.perCellClimate = null;
    st.distToCoast = null;
    st.distWest = null;
    st.distEast = null;
    st.koppenCodes = new Uint8Array(N);

    const S = src.data;
    for (let i = 0; i < N; i++) {
     elev[i] = S[i * 4]; // 0..255 greyscale
    }

    setDimensionsLabel();
    setStatus('Heightmap loaded. Ready to run.');
    runBtn.disabled = false;
    URL.revokeObjectURL(url);
   };
   img.onerror = () => {
    setStatus('Failed to load image. Please try another file.');
    runBtn.disabled = true;
    URL.revokeObjectURL(url);
   };
   img.src = url;
  });

  seaInput.addEventListener('change', () => {
   const st = Program.state;
   const val = parseInt(seaInput.value);
   if (!Number.isFinite(val)) return;
   st.sea = Math.max(0, Math.min(255, val));
   setDimensionsLabel();
  });

  // ----------------------------------------------------
  // --- START: UPDATED PLUGIN REGISTRY ---
  // ----------------------------------------------------

  // ---- PLUGIN 1: Asymmetric Seasonality (UPDATED lat mapping) ----
  Program.register({
    id: 'koppen-latitude-base',
    name: 'Latitude Climate (Asymmetric)',
    uiDesc: 'West coasts get dry summers; East coasts get wet summers.',
    enabled: true,
    async run(st) {
        const { W, H } = st;
        if (!W || !H) return;

        const tempKeys = [
            { lat: 0,  val: 28 }, { lat: 20, val: 26 },
            { lat: 35, val: 22 }, { lat: 50, val: 10 },
            { lat: 70, val: -5 }, { lat: 90, val: -20 }
        ];
        const rainKeys = [
            { lat: 0,  val: 3000 }, { lat: 10, val: 2000 },
            { lat: 20, val: 600 },  { lat: 28, val: 100 },
            { lat: 35, val: 400 },  { lat: 45, val: 1100 },
            { lat: 60, val: 800 },  { lat: 90, val: 200 }
        ];

        function getLerp(deg, keys) {
            for (let i = 0; i < keys.length - 1; i++) {
                const k1 = keys[i];
                const k2 = keys[i+1];
                if (deg >= k1.lat && deg <= k2.lat) {
                    const t = (deg - k1.lat) / (k2.lat - k1.lat);
                    return k1.val + t * (k2.val - k1.val);
                }
            }
            return keys[keys.length-1].val;
        }

        const rows = new Array(H);

        for (let y = 0; y < H; y++) {
            // UPDATED: use configurable latitude band
            const latDeg = latAtRow(y, H, st.latTop, st.latBottom);
            const absLat = Math.abs(latDeg);
            const isNH = latDeg >= 0;

            const T_ann = getLerp(absLat, tempKeys);
            const P_ann = getLerp(absLat, rainKeys);
            const T_amp = 3 + 25 * (absLat / 90);

            const T_row = new Float32Array(12);
            const P_row = new Float32Array(12);
            const twoPi = Math.PI * 2;

            for (let m = 0; m < 12; m++) {
                const phase = twoPi * (m / 12);

                // Temp
                const offset = isNH ? Math.PI : 0;
                T_row[m] = T_ann + T_amp * Math.cos(phase + offset);

                // Seasonality Logic
                let seasonalFactor = 1.0;
                const isSummer = isNH ? (m >= 4 && m <= 9) : (m <= 3 || m >= 9);

                // 1. MONSOON (Tropics 0-20): Always Summer Wet
                if (absLat < 20) {
                    const strength = (20 - absLat) / 20;
                    if (isSummer) seasonalFactor += 1.5 * strength;
                    else seasonalFactor -= 0.8 * strength;
                }

                let Pm = (P_ann / 12) * seasonalFactor;
                if (Pm < 0) Pm = 0;
                P_row[m] = Pm;
            }
            rows[y] = { latDeg, isNH, T_row, P_row };
        }
        st.rowClimate = rows;
    }
  });

  // ---- PLUGIN 2: Directional Coast Scanner (UNCHANGED) ----
  Program.register({
    id: 'koppen-directional-coast',
    name: 'Directional Coast Scanner',
    uiDesc: 'Scans rows West-to-East and East-to-West to find specific upwind distances.',
    enabled: true,
    async run(st) {
        const { W, H, sea, elev } = st;
        if (!W || !H || !elev) return;

        const distWest = new Int32Array(W * H);
        const distEast = new Int32Array(W * H);

        for (let y = 0; y < H; y++) {
            const rowOffset = y * W;

            let run = 0;
            for (let x = 0; x < W; x++) {
                const i = rowOffset + x;
                if (elev[i] < sea) run = 0;
                else run++;
                distWest[i] = run;
            }

            run = 0;
            for (let x = W - 1; x >= 0; x--) {
                const i = rowOffset + x;
                if (elev[i] < sea) run = 0;
                else run++;
                distEast[i] = run;
            }
        }

        st.distWest = distWest;
        st.distEast = distEast;

        st.distToCoast = new Int32Array(W * H);
        for(let i=0; i<W*H; i++) {
            st.distToCoast[i] = Math.min(distWest[i], distEast[i]);
        }
    }
  });

  // ---- PLUGIN 3: Dynamic circulation (UNCHANGED) ----
  Program.register({
    id: 'koppen-dynamic-circulation',
    name: 'Aggressive Circulation & Gyres (2D)',
    uiDesc: 'Adds longitude-dependent waves + interior cooling to break latitudinal bands.',
    enabled: true,
    async run(st) {
        const { W, H, rowClimate, distWest, distEast, elev, sea } = st;
        if (!W || !rowClimate || !distWest || !distEast || !elev) return;

        const perCellClimate = new Array(W * H);
        const KM_PER_PIXEL = 10;

        const getElev = (x, y) => {
            if (x < 0) x += W;
            if (x >= W) x -= W;
            y = Math.max(0, Math.min(H - 1, y));
            return elev[y * W + x];
        };

        function hash2D(x, y) {
            let n = x * 374761393 + y * 668265263;
            n = (n ^ (n >> 13)) * 1274126177;
            n = (n ^ (n >> 16));
            return (n >>> 0) / 4294967295;
        }

        for (let y = 0; y < H; y++) {
            const baseRow = rowClimate[y];
            const { latDeg, isNH } = baseRow;
            const absLat = Math.abs(latDeg);

            for (let x = 0; x < W; x++) {
                const i = y * W + x;
                if (elev[i] < sea) { perCellClimate[i] = null; continue; }

                let windFromWest;
                let upwindDistPx;
                if (absLat < 30) {
                    windFromWest = false;
                    upwindDistPx = distEast[i];
                } else {
                    windFromWest = true;
                    upwindDistPx = distWest[i];
                }

                const upwindKm = upwindDistPx * KM_PER_PIXEL;
                const continentality = Math.min(1.0, upwindKm / 2000);

                const T_row = new Float32Array(baseRow.T_row);
                const P_row = new Float32Array(baseRow.P_row);

                const nx = x / W;
                const ny = y / H;

                const w1 = Math.sin(2 * Math.PI * (nx * 2.5 + ny * 0.35));
                const w2 = Math.sin(2 * Math.PI * (nx * 4.1 - ny * 0.18));
                let wave = 0.6 * w1 + 0.4 * w2;
                const waveNorm = Math.max(-1, Math.min(1, wave));

                const tropicWeight   = Math.max(0, 1 - absLat / 30);
                const midLatWeight   = Math.max(0, 1 - Math.abs(absLat - 40) / 20);
                const highLatWeight  = Math.max(0, 1 - Math.abs(absLat - 65) / 20);

                const tempWaveAmp =
                    2.0 * tropicWeight +
                    5.0 * midLatWeight +
                    1.5 * highLatWeight;

                const rainWaveAmp =
                    0.4 * tropicWeight +
                    0.3 * midLatWeight +
                    0.15 * highLatWeight;

                let tempWave = waveNorm * tempWaveAmp;
                let rainWave = waveNorm * rainWaveAmp;

                const jitter = (hash2D(x, y) - 0.5);
                tempWave += jitter * 0.7;
                rainWave += jitter * 0.08;

                let tempOffsetWinter = 0;
                let rainMult = 1.0;

                if (absLat > 35 && absLat < 65 && windFromWest) {
                    if (continentality < 0.5) {
                        const heatBoost = 10.0 * (1.0 - continentality / 0.5);
                        tempOffsetWinter += heatBoost;
                        rainMult *= 1.4;
                    }
                    if (continentality > 0.6) {
                        tempOffsetWinter -= 5.0;
                    }
                }

                if (absLat > 15 && absLat < 35) {
                    const isWestSide = distWest[i] < distEast[i];

                    if (isWestSide) {
                        if (distWest[i] * KM_PER_PIXEL < 400) {
                            rainMult *= 0.2;
                            tempOffsetWinter -= 2.0;
                        }
                    } else {
                        if (distEast[i] * KM_PER_PIXEL < 400) {
                            rainMult *= 1.7;
                            tempOffsetWinter += 3.0;
                        }
                    }
                }

                const lookBack = 3;
                const upwindX = windFromWest ? (x - lookBack) : (x + lookBack);
                const slope = elev[i] - getElev(upwindX, y);

                rainMult *= (1.0 - continentality * 0.5);

                if (slope > 5) {
                    rainMult *= (1.0 + Math.min(0.9, slope / 8));
                } else if (slope < -5) {
                    rainMult *= 0.25;
                }

                const interiorCoolMidLats = 6.0 * continentality * midLatWeight;
                const interiorHotTropics  = 3.0 * continentality * tropicWeight;

                let tempAllSeasonsOffset = -interiorCoolMidLats + interiorHotTropics;

                rainMult *= (1.0 + rainWave);
                if (rainMult < 0.05) rainMult = 0.05;
                if (rainMult > 4.5)  rainMult = 4.5;

                tempOffsetWinter += tempWave * 0.7;
                tempAllSeasonsOffset += tempWave * 0.3;

                for (let m = 0; m < 12; m++) {
                    const isSummer = isNH ? (m >= 4 && m <= 9) : (m <= 3 || m >= 9);
                    const isWinter = !isSummer;

                    P_row[m] *= rainMult;
                    if (P_row[m] < 0) P_row[m] = 0;

                    T_row[m] += tempAllSeasonsOffset;
                    if (isWinter) T_row[m] += tempOffsetWinter;
                    else T_row[m] += tempOffsetWinter * 0.2;
                }

                perCellClimate[i] = { T_row, P_row };
            }

            if (y % 100 === 0) await new Promise(r => setTimeout(r, 0));
        }

        st.perCellClimate = perCellClimate;
    }
  });

  // ---- CLASSIFICATION FUNCTION (UNCHANGED) ----
  function classifyKoppenForCell(row, elevMeters) {
    const { latDeg, isNH, T_row, P_row } = row;

    const elevKm = Math.max(0, elevMeters) / 1000;
    const lapse = -6.5;
    const dT = lapse * elevKm;

    const Tm = new Float32Array(12);
    let T_ann = 0;
    let Tcold = 1000;
    let Twarm = -1000;
    let nGT10 = 0;

    for (let m = 0; m < 12; m++) {
        const t = T_row[m] + dT;
        Tm[m] = t;
        T_ann += t;
        if (t < Tcold) Tcold = t;
        if (t > Twarm) Twarm = t;
        if (t > 10) nGT10++;
    }
    T_ann /= 12;

    let P_ann = 0;
    let P_summer = 0;
    let P_winter = 0;

    const summerMonths = isNH ? [3,4,5,6,7,8] : [9,10,11,0,1,2];

    let P_drySummer = 10000, P_wetSummer = -1;
    let P_dryWinter = 10000, P_wetWinter = -1;

    for (let m = 0; m < 12; m++) {
        const Pm = P_row[m];
        P_ann += Pm;

        if (summerMonths.includes(m)) {
            P_summer += Pm;
            if (Pm < P_drySummer) P_drySummer = Pm;
            if (Pm > P_wetSummer) P_wetSummer = Pm;
        } else {
            P_winter += Pm;
            if (Pm < P_dryWinter) P_dryWinter = Pm;
            if (Pm > P_wetWinter) P_wetWinter = Pm;
        }
    }

    let P_th;
    const fracSummer = P_summer / P_ann;
    const fracWinter = P_winter / P_ann;

    if (fracSummer >= 0.7)      P_th = 20 * T_ann + 280;
    else if (fracWinter >= 0.7) P_th = 20 * T_ann;
    else                        P_th = 20 * T_ann + 140;

    if (Twarm < 10) {
        return Twarm <= 0 ? CODE_TO_INDEX['EF'] : CODE_TO_INDEX['ET'];
    }

    if (P_ann < P_th) {
        const isHot = T_ann >= 18;
        const isDesert = P_ann < (0.5 * P_th);
        if (isDesert) return isHot ? CODE_TO_INDEX['BWh'] : CODE_TO_INDEX['BWk'];
        else          return isHot ? CODE_TO_INDEX['BSh'] : CODE_TO_INDEX['BSk'];
    }

    if (Tcold >= 18) {
        let P_min = 10000;
        for(let m=0; m<12; m++) if(P_row[m] < P_min) P_min = P_row[m];

        if (P_min >= 60) return CODE_TO_INDEX['Af'];
        if (P_ann >= 25 * (100 - P_min)) return CODE_TO_INDEX['Am'];

        if (P_drySummer < P_dryWinter) return CODE_TO_INDEX['As'];
        return CODE_TO_INDEX['Aw'];
    }

    const isGroupC = (Tcold > -3);

    let secondLetter = 'f';
    if (P_drySummer < 40 && P_drySummer < (P_wetWinter / 3)) secondLetter = 's';
    else if (P_dryWinter < (P_wetSummer / 10)) secondLetter = 'w';

    let thirdLetter;
    if (Twarm >= 22) thirdLetter = 'a';
    else if (nGT10 >= 4) thirdLetter = 'b';
    else if (Tcold < -38) thirdLetter = 'd';
    else thirdLetter = 'c';

    const group = isGroupC ? 'C' : 'D';
    const code = group + secondLetter + thirdLetter;

    if (CODE_TO_INDEX[code] !== undefined) return CODE_TO_INDEX[code];
    return isGroupC ? CODE_TO_INDEX['Cfb'] : CODE_TO_INDEX['Dfb'];
  }

  // ---- PLUGIN 4: Elevation + Köppen index (UNCHANGED) ----
  Program.register({
    id: 'koppen-elev-index',
    name: 'Elevation + Köppen Index',
    uiDesc: 'Applies lapse rate from the heightmap and classifies each land cell into a raw Köppen class.',
    enabled: true,
    async run(st) {
       const { W, H, sea, elev, rowClimate, perCellClimate, koppenCodes } = st;
       if (!W || !H || !perCellClimate || !koppenCodes) {
         setStatus('Missing data for classification.');
         return;
       }
       const seaGray = sea;
       const maxLandGray = Math.max(1, 255 - seaGray);
       const maxElevMeters = 8550;

       for (let y = 0; y < H; y++) {
         const baseRow = rowClimate[y];
         for (let x = 0; x < W; x++) {
           const i = y * W + x;
           const g = elev[i];
           if (g < seaGray) { koppenCodes[i] = 255; continue; }

           const cellClimate = perCellClimate[i];
           const modifiedRow = {
              latDeg: baseRow.latDeg,
              isNH: baseRow.isNH,
              T_row: cellClimate.T_row,
              P_row: cellClimate.P_row
           };

           const landGray = g - seaGray;
           const elevMeters = (landGray / maxLandGray) * maxElevMeters;

           let classIndex = classifyKoppenForCell(modifiedRow, elevMeters);

           const elevKm = elevMeters / 1000;
           const baseCode = KOPPEN_CLASSES[classIndex].code;
           if (elevKm >= 2.5) {
             if (baseCode[0] !== 'E' && baseCode[0] !== 'B') classIndex = CODE_TO_INDEX['H'];
           }
           koppenCodes[i] = classIndex;
         }
         if (y % 256 === 0) await new Promise(r => setTimeout(r, 0));
       }
     }
  });

  // ---- PLUGIN 5: Smoothing (UNCHANGED) ----
  Program.register({
    id: 'koppen-smooth',
    name: 'Köppen Majority Smoothing',
    uiDesc: 'Shrinks tiny outlier patches and softens harsh pixel noise.',
    enabled: true,
    async run(st) {
        const { W, H, koppenCodes } = st;
        if (!W || !H || !koppenCodes) return;

        const N = W * H;
        const tmp = new Uint8Array(N);
        const neighbors = [
            [-1, -1], [0, -1], [1, -1],
            [-1,  0],          [1,  0],
            [-1,  1], [0,  1], [1,  1],
        ];

        const passes = 2;

        for (let pass = 0; pass < passes; pass++) {
            tmp.set(koppenCodes);

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    const c = tmp[i];
                    if (c === 255) continue;

                    const counts = new Map();
                    let sameCount = 0;

                    for (const [dx, dy] of neighbors) {
                        let nx = x + dx;
                        let ny = y + dy;
                        if (nx < 0) nx += W;
                        if (nx >= W) nx -= W;
                        if (ny < 0 || ny >= H) continue;
                        const ni = ny * W + nx;
                        const nc = tmp[ni];
                        if (nc === 255) continue;
                        if (nc === c) sameCount++;
                        counts.set(nc, (counts.get(nc) || 0) + 1);
                    }

                    let bestC = c;
                    let bestCount = sameCount;

                    for (const [cc, count] of counts) {
                        if (count > bestCount) {
                            bestCount = count;
                            bestC = cc;
                        }
                    }

                    if (bestC !== c && bestCount >= 4 && sameCount <= 2) {
                        koppenCodes[i] = bestC;
                    }
                }
            }
        }
    }
  });

  // ---- PLUGIN 6: Lowland warp (UPDATED lat mapping) ----
  Program.register({
    id: 'koppen-lowland-warp',
    name: 'Lowland Domain Warp (Anti-Banding)',
    uiDesc: 'Smooth 2D domain warping of lowland climates only, avoiding ocean & highlands to break residual banding.',
    enabled: true,
    async run(st) {
        const { W, H, sea, elev, koppenCodes } = st;
        if (!W || !H || !elev || !koppenCodes) return;

        setStatus('Lowland domain warp…');

        const N = W * H;

        const seaGray = sea;
        const maxLandGray = Math.max(1, 255 - seaGray);
        const maxElevMeters = 8550;
        const lowlandMaxMeters = 1500;

        const lowlandMask = new Uint8Array(N);
        const landMask = new Uint8Array(N);

        for (let i = 0; i < N; i++) {
            const g = elev[i];
            if (g < seaGray) { landMask[i] = 0; lowlandMask[i] = 0; continue; }
            landMask[i] = 1;
            const landGray = g - seaGray;
            const elevMeters = (landGray / maxLandGray) * maxElevMeters;
            lowlandMask[i] = (elevMeters < lowlandMaxMeters) ? 1 : 0;
        }

        const twoPi = Math.PI * 2;

        function vecNoise(nx, ny) {
            const sx1 = Math.sin(twoPi * (nx * 3.17 + ny * 1.23));
            const sx2 = Math.sin(twoPi * (nx * 7.13 - ny * 0.92));
            const sy1 = Math.sin(twoPi * (nx * 2.11 - ny * 3.41));
            const sy2 = Math.sin(twoPi * (nx * 5.33 + ny * 1.71));
            const vx = (sx1 * 0.6 + sx2 * 0.4);
            const vy = (sy1 * 0.6 + sy2 * 0.4);
            return [vx, vy];
        }

        const BASE_WARP_PX = 64;

        const newCodes = new Uint8Array(N);
        newCodes.set(koppenCodes);

        function wrapX(x) {
            if (x < 0) x = (x % W + W) % W;
            else if (x >= W) x = x % W;
            return x;
        }
        function clampY(y) {
            if (y < 0) return 0;
            if (y >= H) return H - 1;
            return y;
        }

        // UPDATED: latitude degrees per row from configurable band
        const latDegRow = new Float32Array(H);
        for (let y = 0; y < H; y++) {
            latDegRow[y] = latAtRow(y, H, st.latTop, st.latBottom);
        }

        for (let y = 0; y < H; y++) {
            const latDeg = latDegRow[y];
            const absLat = Math.abs(latDeg);

            const lowLatWeight = Math.max(0, 1 - absLat / 45);
            const midLatBoost = Math.max(0, 1 - Math.abs(absLat - 40) / 20);
            const latWeight = Math.min(1, 0.4 + 0.6 * (0.7 * lowLatWeight + 0.3 * midLatBoost));

            for (let x = 0; x < W; x++) {
                const i = y * W + x;
                const ci = koppenCodes[i];

                if (!landMask[i] || !lowlandMask[i] || ci === 255) {
                    newCodes[i] = ci;
                    continue;
                }

                const localWarpPx = BASE_WARP_PX * latWeight;
                if (localWarpPx < 1.0) { newCodes[i] = ci; continue; }

                const nx = x / W;
                const ny = y / H;
                const [vx, vy] = vecNoise(nx, ny);

                let dx = vx * localWarpPx;
                let dy = vy * localWarpPx;

                let sampleCode = ci;
                let found = false;

                for (let attempt = 0; attempt < 3; attempt++) {
                    const tx = wrapX(Math.round(x + dx));
                    const ty = clampY(Math.round(y + dy));
                    const ti = ty * W + tx;

                    if (landMask[ti] && lowlandMask[ti] && koppenCodes[ti] !== 255) {
                        sampleCode = koppenCodes[ti];
                        found = true;
                        break;
                    }

                    dx *= 0.5;
                    dy *= 0.5;
                }

                newCodes[i] = found ? sampleCode : ci;
            }

            if ((y & 0xff) === 0) await new Promise(r => setTimeout(r, 0));
        }

        koppenCodes.set(newCodes);
    }
  });

  // ---- FINAL: Render (UNCHANGED) ----
  Program.register({
   id: 'koppen-render',
   name: 'Render Köppen Map',
   uiDesc: 'Renders class colors to the canvas and summarizes dominant types.',
   enabled: true,
   async run(st) {
    const { W, H, koppenCodes, work } = st;
    if (!W || !H || !koppenCodes || !work) { setStatus('Missing canvas, indices, or work buffer.'); return; }

    const out = work.data;
    const oceanColor = [10, 30, 80];
    const classCounts = new Array(KOPPEN_CLASSES.length).fill(0);

    for (let i = 0; i < koppenCodes.length; i++) {
     const idx4 = i * 4;
     const ci = koppenCodes[i];
     if (ci === 255) {
      out[idx4 + 0] = oceanColor[0];
      out[idx4 + 1] = oceanColor[1];
      out[idx4 + 2] = oceanColor[2];
      out[idx4 + 3] = 255;
     } else {
      const cl = KOPPEN_CLASSES[ci];
      const rgb = hexToRgb(cl.color);
      out[idx4 + 0] = rgb[0];
      out[idx4 + 1] = rgb[1];
      out[idx4 + 2] = rgb[2];
      out[idx4 + 3] = 255;
      classCounts[ci]++;
     }
    }

    ctx.putImageData(work, 0, 0);

    const totalLand = classCounts.reduce((a, b) => a + b, 0);
    let lines = [];
    lines.push(`Land pixels: ${totalLand.toLocaleString()}`);
    if (totalLand > 0) {
     const top = [...classCounts.entries()]
      .filter(([idx, c]) => c > 0)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);
     lines.push('Dominant classes:');
     top.forEach(([idx, c]) => {
      const cl = KOPPEN_CLASSES[idx];
      const pct = (c * 100 / totalLand).toFixed(1);
      lines.push(`• ${cl.code} (${cl.name}) — ${pct}%`);
     });
    }
    metricsEl.textContent = lines.join('\n');
   }
  });

  // ----------------------------------------------------
  // --- END: UPDATED PLUGIN REGISTRY ---
  // ----------------------------------------------------

  Program.renderPluginUI();

  // ---- Run button (sync lat band before run) ----
  runBtn.addEventListener('click', async () => {
   const st = Program.state;
   if (!st.W || !st.H || !st.elev) { setStatus('Upload a heightmap first.'); return; }

   st.sea = parseInt(seaInput.value) || 19;
   syncLatBand(); // ADDED
   setDimensionsLabel();

   setStatus('Running pipeline…');
   runBtn.disabled = true;
   try {
    await Program.run();
   } catch (err) {
    console.error(err);
    setStatus('Error during generation. See console.');
   } finally {
    runBtn.disabled = false;
   }
  });
 </script>
</body>
</html>
